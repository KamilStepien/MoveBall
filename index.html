<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="style.css">
    <title>Document</title>
</head>
<body>

    
    <canvas id= "can" width= "500px" height = "500px" >

    </canvas>


       
     
</body>
<script>

   


    class ball
    {

        constructor (x , y , radius)
        {
            this.x = x;
            this.y = y;
            this.radius = radius;
          
        }  


        
         isColision(entity2) {
         return !(this.x-this.radius + this.radius*2 < entity2.x ||
               entity2.x + entity2.width < this.x-this.radius ||
               this.y-this.radius + this.radius*2 < entity2.y ||
               entity2.y + entity2.height < this.y-this.radius);
        }

        isOverColision(entity2)
        {
           return  this.isColision(entity2) && this.y-this.radius + this.radius*2 == entity2.y
        }
        isUnderColision(entity2)
        {
           return  this.isColision(entity2) && this.y-this.radius  == entity2.y+entity2.height
        }
        isLeftColision(entity2)
        {
           return  this.isColision(entity2) && this.x-this.radius  == entity2.x+entity2.width
        }
        isRightColision(entity2)
        {
           return  this.isColision(entity2) && this.x-this.radius + this.radius*2  == entity2.x;
        }
       


        

       
    }


    class Element 
    {
        
        constructor (x , y , height , width ,name)
        {
            this.x = x;
            this.y = y;
            this.height = height;
            this.width = width;
            this.name = name;
            this.active = true;
        }

         //////////////////////////////////
        //funkcja odpowiedzialna za rysowanie scian
         drawElement(ctx)
        {
            if(this.active)
                {
                    ctx.beginPath();
                    ctx.rect(this.x, this.y, this.width, this.height);
                    ctx.fillStyle = "red";
                    ctx.fill()
                }
        

        }

    }
    
    let output = document.querySelector('.output');  
   

    ///////////test /?//////////////////
    //tablica scian 
    let tabElement = [];
    tabElement.push(new Element(60,300,100,100 ,"wall"));
    tabElement.push(new Element(300,300,10,100,"wall"));
    tabElement.push(new Element(265,0,100,10,"wall"));
    tabElement.push(new Element(300,0,100,10,"wall"));
    tabElement.push(new Element(100,100,10,10,"maxSize"));
    tabElement.push(new Element(100,200,10,10,"minSize"));
    //odwołanie do canvasa
    let canvasElem = document.querySelector('#can');
    let ctx = canvasElem.getContext('2d');
    
    for(let i =0  ; i < tabElement.length ; i++)
    {
        console.log("rysowanie");
        tabElement[i].drawElement(ctx);
    }

   
    //////////////////////////////!!!!!!!!!!!!!!!!!!!!!!!
    
    let Ball = new ball(40,40,10)
    let lastBeta=0;
    let lastGamma=0;
    let y =0;
    let x =0;
    let moveX =0;
    let moveY =0;
    
    function handleOrientation(event) {
        
        lastBeta =y;
        lastGamma = x;
         y = event.beta;  // In degree in the range [-180,180]
         x = event.gamma; // In degree in the range [-90,90]
        // Because we don't want to have the device upside down
        // We constrain the x value to the range [-90,90]
        if (x > 90) { x = 90 };
        if (x < -90) { x = -90 };
        
        if(Math.abs(x)+Math.abs(lastGamma) > Math.abs(y)+Math.abs(lastBeta))
        {
            if(x>0)
            {
                moveX =-1; moveY = 0;
            }
            if(x<0)
            {
                moveX =1; moveY = 0;
                
            }
        }
        else
        {
            if(y>0)
            {
                moveY =1; moveX = 0;
            }
            if(y<0)
            {
                
                moveY =-1; moveX = 0;
            }
        }
        
        //moveX = x/90;
        
        //moveY = y/40;

    }
    window.addEventListener('deviceorientation', handleOrientation);


    //sterowanie za pomocą szczałek - tymczasowe ;

    document.addEventListener("keypress", (e)=>
    {
        console.log("charcode "+ e.charCode)
        switch(e.keyCode)
        {
            case 119:moveY =-1; moveX = 0;
            break;//w
            case 115:moveY =1; moveX = 0;
            break;//s
            case 97:moveX =-1; moveY = 0;
            break;//a
            case 100:moveX =1; moveY = 0;
            break;//d
        }
        


    }
    
    )




    //funkcja odpowiedzialna za przesuwanie i rysowanie kuli 
    function moveBall(_Ball , _moveX , _moveY)
    {   
        //czyszczenie poprzedniej piłki 
        ctx.clearRect( _Ball.x-_Ball.radius-1,_Ball.y-_Ball.radius-1,_Ball.radius*2+2,_Ball.radius*2+2);

        //rysowanie nowej piłki
        ctx.beginPath();
        ctx.fillStyle = "rgb(0,0,0)";
        _Ball.x+=_moveX;
        _Ball.y+=_moveY;
        ctx.arc( _Ball.x,_Ball.y,_Ball.radius,0,360*Math.PI/180);
        ctx.fill();
        ctx.closePath(); 
       
    }  
    //odpowieada za odpalanie funkcji moveBall co 5 ms , dzieki czemu  piłka porusza się cały czas w odpowiednim kierunku
    
 
    

        setInterval(()=> 
        {
            
            for(let a = 0 ; a<tabElement.length ; a++) 
            {
                console.log(" csadd " +Ball.isColision(tabElement[a]));
                if(Ball.isColision(tabElement[a]) &&  tabElement[a].name=="wall")
                {
                    if(Ball.isOverColision(tabElement[a]))
                    {
                        moveBall(Ball,moveX,-Math.abs(moveY))
                    }
                    if(Ball.isUnderColision(tabElement[a]))
                    {
                        moveBall(Ball,moveX,Math.abs(moveY))
                    }
                    if(Ball.isLeftColision(tabElement[a]))
                    {
                        moveBall(Ball,Math.abs(moveX),moveY)
                    }
                    if(Ball.isRightColision(tabElement[a]))
                    {
                        moveBall(Ball,-Math.abs(moveX),moveY)
                    }
                }
                if(Ball.isColision(tabElement[a]) &&  tabElement[a].name=="maxSize" &&tabElement[a].active==true)
                {
                   
                    Ball.radius =20;
                    tabElement[a].name = "";
                }
                if(Ball.isColision(tabElement[a]) &&  tabElement[a].name=="minSize"  &&tabElement[a].active==true)
                {
                    ctx.clearRect( Ball.x-Ball.radius-1,Ball.y-Ball.radius-1,Ball.radius*2+2,Ball.radius*2+2);
                    Ball.radius =10;
                    tabElement[a].name = "";
                }
                
            }
            if(!(Ball.isColision(tabElement[0])||Ball.isColision(tabElement[1])||Ball.isColision(tabElement[2])||Ball.isColision(tabElement[3])))
                 moveBall(Ball,moveX,moveY)
                
               
                



        }
        ,10);  
            
        
    
           // if(Ball.x + Ball.radius+1 <= tabWall[0].x | Ball.x + Ball.radius+1 >= tabWall[0].x+tabWall[0].width)
           // {
          //      moveBall(Ball,moveX,moveY); 
          //  }
           // else
           // moveBall(Ball,0,moveY); 
            
        
         
            
            
           
        
    
</script>
</html>